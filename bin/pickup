#!/bin/bash
# pickup - Pull all changes when arriving at a machine
# Usage: pickup [--skip-install] [--status]

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Config
CONFIG_DIR="${HANDOFF_CONFIG_DIR:-$HOME/.config/handoff}"
PROJECTS_FILE="$CONFIG_DIR/projects"

# Helper functions
print_header() {
    echo -e "\n${BLUE}[$1]${NC}"
}

print_success() {
    echo -e "  ${GREEN}✓${NC} $1"
}

print_warning() {
    echo -e "  ${YELLOW}⚠${NC} $1"
}

print_error() {
    echo -e "  ${RED}✗${NC} $1"
}

print_info() {
    echo -e "  $1"
}

# Check if a tool version manager file exists and run install
run_install_tools() {
    local project="$1"
    local skip_install="$2"

    if [ "$skip_install" = true ]; then
        return 0
    fi

    cd "$project"

    # mise / asdf
    if [ -f ".tool-versions" ]; then
        if command -v mise &> /dev/null; then
            print_info "Running: mise install"
            mise install --yes 2>/dev/null || print_warning "mise install had issues"
        elif command -v asdf &> /dev/null; then
            print_info "Running: asdf install"
            asdf install 2>/dev/null || print_warning "asdf install had issues"
        fi
    fi

    # Node.js
    if [ -f "package-lock.json" ] || [ -f "yarn.lock" ] || [ -f "pnpm-lock.yaml" ]; then
        if [ -f "pnpm-lock.yaml" ] && command -v pnpm &> /dev/null; then
            print_info "Running: pnpm install"
            pnpm install 2>/dev/null || print_warning "pnpm install had issues"
        elif [ -f "yarn.lock" ] && command -v yarn &> /dev/null; then
            print_info "Running: yarn install"
            yarn install 2>/dev/null || print_warning "yarn install had issues"
        elif [ -f "package-lock.json" ] && command -v npm &> /dev/null; then
            print_info "Running: npm ci"
            npm ci 2>/dev/null || npm install 2>/dev/null || print_warning "npm install had issues"
        fi
    fi

    # Python
    if [ -f "requirements.txt" ]; then
        if [ -d "venv" ] || [ -d ".venv" ]; then
            print_info "Python venv detected (activate manually if needed)"
        fi
    fi

    # Go
    if [ -f "go.mod" ]; then
        if command -v go &> /dev/null; then
            print_info "Running: go mod download"
            go mod download 2>/dev/null || print_warning "go mod download had issues"
        fi
    fi
}

# Process a single project
process_project() {
    local project="$1"
    local skip_install="$2"
    local status_only="$3"

    print_header "$project"

    # Check if directory exists
    if [ ! -d "$project" ]; then
        print_error "Directory not found"
        return 1
    fi

    # Check if it's a git repo
    if [ ! -d "$project/.git" ]; then
        print_error "Not a git repository"
        return 1
    fi

    cd "$project"

    # Get current branch
    local branch=$(git branch --show-current 2>/dev/null || echo "detached")
    print_info "Branch: $branch"

    # Status only mode
    if [ "$status_only" = true ]; then
        local ahead=$(git rev-list --count @{u}..HEAD 2>/dev/null || echo "?")
        local behind=$(git rev-list --count HEAD..@{u} 2>/dev/null || echo "?")
        print_info "Ahead: $ahead, Behind: $behind"
        return 0
    fi

    # Fetch first
    print_info "Fetching origin..."
    git fetch origin 2>/dev/null || {
        print_warning "Could not fetch (no remote?)"
        return 0
    }

    # Check if we have an upstream
    local upstream=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || echo "")

    if [ -z "$upstream" ]; then
        print_warning "No upstream branch set"
        return 0
    fi

    # Check if behind remote
    local behind=$(git rev-list --count HEAD..@{u} 2>/dev/null || echo "0")

    if [ "$behind" -gt 0 ]; then
        # Check for local changes that would conflict
        if [ -n "$(git status --porcelain)" ]; then
            print_warning "Local changes detected - stashing first"
            git stash push -m "pickup auto-stash"
            git pull --rebase=false
            print_info "Restoring stashed changes..."
            git stash pop || print_warning "Could not restore stash (conflicts?)"
        else
            git pull --rebase=false
        fi
        print_success "Pulled $behind commit(s) from origin/$branch"
    else
        print_success "Already up to date"
    fi

    # Run install tools
    run_install_tools "$project" "$skip_install"

    return 0
}

# Main pickup function
run_pickup() {
    local skip_install=false
    local status_only=false

    # Parse flags
    while [[ "$1" == --* ]]; do
        case "$1" in
            --skip-install)
                skip_install=true
                shift
                ;;
            --status)
                status_only=true
                shift
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                exit 1
                ;;
        esac
    done

    echo -e "${BLUE}Pickup starting...${NC}"

    if [ "$skip_install" = true ]; then
        echo -e "${YELLOW}(Skipping dependency installs)${NC}"
    fi

    if [ "$status_only" = true ]; then
        echo -e "${YELLOW}(Status only)${NC}"
    fi

    # Check if projects file exists and has entries
    if [ ! -f "$PROJECTS_FILE" ] || [ ! -s "$PROJECTS_FILE" ]; then
        echo -e "\n${YELLOW}No projects registered.${NC}"
        echo -e "Use '${BLUE}handoff add /path/to/project${NC}' to register projects."
        exit 0
    fi

    local failed=0

    while IFS= read -r project; do
        # Skip empty lines and comments
        [[ -z "$project" || "$project" == \#* ]] && continue

        process_project "$project" "$skip_install" "$status_only" || ((failed++))
    done < "$PROJECTS_FILE"

    # Summary
    echo -e "\n${BLUE}────────────────────────────${NC}"
    if [ "$status_only" = true ]; then
        echo -e "${GREEN}Status check complete.${NC}"
    elif [ "$failed" -eq 0 ]; then
        echo -e "${GREEN}Pickup complete.${NC}"
        echo -e "${GREEN}Ready to work.${NC}"
    else
        echo -e "${YELLOW}Pickup complete with $failed issue(s).${NC}"
    fi
}

# Main entry point
case "${1:-}" in
    help|--help|-h)
        echo "pickup - Pull all changes when arriving at a machine"
        echo ""
        echo "Usage:"
        echo "  pickup                Run pickup on all registered projects"
        echo "  pickup --skip-install Skip running dependency installs"
        echo "  pickup --status       Just show sync status of all projects"
        echo "  pickup help           Show this help"
        echo ""
        echo "To manage projects, use the 'handoff' command:"
        echo "  handoff add PATH      Register a project"
        echo "  handoff remove PATH   Unregister a project"
        echo "  handoff list          List registered projects"
        ;;
    *)
        run_pickup "$@"
        ;;
esac
